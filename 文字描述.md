
# 方案1

## 实现消息提醒任务即将到期

NestJS提供了一个轻量级的定时任务模块，可以使用它来创建定时任务。

基于这一点，我们可以创建一个定时任务，每天检查即将到期的任务并发送消息提醒。 

如果需求是提醒三天之内到期的任务，我们可以设置定时任务每隔一分钟执行一次。

定时任务会读取所有TodoStatus为Todo的任务，检查endDate和今天相差的天数。


如果在三天以内的话，则发送消息提醒给用户。可以新建一张消息表用于存储用户消息。

消息标题为：任务即将到期，请尽快处理。

然后再设计一个API用于返回用户的最新消息。

在React中，可以使用WebSocket或者轮询后端接口来获取即将到期的任务，然后在前端进行消息提醒的展示。


## 定时重复任务

如果任务没有完成，我们需要重复提醒，这时因为TodoStatus仍然为Todo，所以依然会被定时任务扫描到。

不过我们需要修改一下判断逻辑，如果endDate和今天的日期相比较，已经过期的话，我们也存储一条用户消息到消息表中。

消息标题为：任务已经过期，请尽快处理。

如果用户一直没有完成这项任务的话，则会一直收到消息提醒，直到用户完成为止。

## 优缺点

优点：实现容易，成本低，基本不依赖其他组件。


缺点：

- 时间可能不够精确。由于定时任务扫描的间隔是固定的，所以可能造成一些任务已经过期了一段时间才被扫描到，任务提醒的时间比正常时间晚一些。

- 增加了数据库的压力。随着任务的数量越来越多，扫描的成本也会越来越大，执行时间也会被拉长，可能导致某些应该被提醒的任务迟迟没有提醒。





# 方案2

## 实现消息提醒任务即将到期

方案一虽然可以满足需求，但是当系统的数据量很大的时候还是比较消耗系统资源的，而且这种方式对于任务的提醒还是有延迟。

我们可以考虑使用RocketMQ延迟队列，在任务创建之后，我们就可以把任务作为一条消息投递到rocketmq。

并将延迟时间设置为任务的截至时间之前的30分钟，这样，我们定义的consumer在任务在30分钟即将到期的时候就可以消费到这条消息。

然后检查用户是否完成了这个任务。如果如果没有完成，则保存到用户消息表推送给用户。

## 定时重复任务

我们在收到消息后，如果任务还没有完成，可以再向rabbitmq发送一条延迟消息，比如如果希望定时30分钟提醒一次

那么就将这条消息的延迟时间设置为30分钟，那么在30分钟之后，consumer将再次收到这条消息，如果用户已经完成了任务。

那么就不需要提醒，如果用户仍然没有完成，则推送消息给用户并且再次发送延迟消息，直到用户完成任务。


## 优缺点

优点：可以使代码逻辑清晰，系统之间完全解耦，只需关注生产及消费消息即可。另外其吞吐量极高，最多可以支撑万亿级的数据量。

缺点：相对来说mq是重量级的组件，引入mq之后，随之而来的消息丢失、幂等性问题等都加深了系统的复杂度。




# 方案3

## 实现消息提醒任务即将到期

可以利用redis中key自动过期机制，提交任务时将任务编号写入redis，并设置任务的过期时间。

当任务过期后，取到过期的key就可以拿到所有即将过期的任务，

对于还没有完成的任务执行提醒消息操作。将消息保存到用户消息表。


## 定时重复任务

和方案二类似，如果用户没有完成，我们再向redis中保存这个任务，过期时间为重复提醒时间，比如三十分钟。

那么在30分钟之后，订阅者将再次收到这条消息。

如果用户已经完成了任务。过期的key将被删除。

如果没有完成，则推送消息给用户并且订阅者再次向redis中保存任务，直到用户完成任务。


## 优缺点

优点： 由于redis的高性能，所以我们在设置key，或者消费key时，速度上是可以保证的。

缺点：由于redis的key过期策略原因，当一个key过期时，redis无法保证立刻将其删除，自然我们的监听事件也无法第一时间消费到这个key，所以会存在一定的延迟。另外，在redis5.0之前，订阅发布中的消息并没有被持久化，自然也没有所谓的确认机制。所以一旦消费消息的过程中我们的客户端发生了宕机，这条消息就彻底丢失了。
